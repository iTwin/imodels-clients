/*---------------------------------------------------------------------------------------------
 * Copyright (c) Bentley Systems, Incorporated. All rights reserved.
 * See LICENSE.md in the project root for license terms and full copyright notice.
 *--------------------------------------------------------------------------------------------*/
import * as fs from "fs";
import { iModelsClient as AuthoringiModelsClient } from "@itwin/imodels-client-authoring";
import { iModelsClient as ManagementiModelsClient, RequestContext, iModel } from "@itwin/imodels-client-management";
import { TestiModelGroup } from "./TestiModelGroup";
import { TestiModelMetadata } from "./TestiModelMetadata";

export class TestSetupError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "TestSetupFailed";
  }
}

export function sleep(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

export function createEmptyiModel(params: {
  imodelsClient: ManagementiModelsClient | AuthoringiModelsClient,
  requestContext: RequestContext,
  projectId: string,
  imodelName: string
}): Promise<iModel> {
  return params.imodelsClient.iModels.createEmpty({
    requestContext: params.requestContext,
    imodelProperties: {
      projectId: params.projectId,
      name: params.imodelName
    }
  });
}

export async function toArray<T>(iterator: AsyncIterableIterator<T>): Promise<T[]> {
  const result: T[] = [];
  for await (const entity of iterator)
    result.push(entity);

  return result;
}

export async function createDefaultTestiModel(params: {
  imodelsClient: AuthoringiModelsClient,
  requestContext: RequestContext,
  projectId: string,
  imodelName: string
}): Promise<iModel> {
  const imodel = await params.imodelsClient.iModels.createEmpty({
    requestContext: params.requestContext,
    imodelProperties: {
      projectId: params.projectId,
      name: params.imodelName
    }
  });

  const briefcase = await params.imodelsClient.Briefcases.acquire({
    requestContext: params.requestContext,
    imodelId: imodel.id,
    briefcaseProperties: {
      deviceName: TestiModelMetadata.Briefcase.deviceName
    }
  });

  // Briefcase id is generated by the iModels API but usually the first briefcase id has a value of 2.
  // We assert the expected value here to be sure so that later we could use it in read operation test asserts.
  if (briefcase.briefcaseId !== TestiModelMetadata.Briefcase.id)
    throw new TestSetupError(`Unexpected briefcaseId: expected the default iModel briefcase to equal ${TestiModelMetadata.Briefcase.id}`);

  for (let i = 0; i < TestiModelMetadata.Changesets.length; i++) {
    await params.imodelsClient.Changesets.create({
      requestContext: params.requestContext,
      imodelId: imodel.id,
      changesetProperties: {
        briefcaseId: briefcase.briefcaseId,
        description: TestiModelMetadata.Changesets[i].description,
        containingChanges: TestiModelMetadata.Changesets[i].containingChanges,
        id: TestiModelMetadata.Changesets[i].id,
        parentId: i == 0
          ? undefined
          : TestiModelMetadata.Changesets[i - 1].id,
        changesetFilePath: TestiModelMetadata.Changesets[i].changesetFilePath
      }
    });
  }

  return imodel;
}

export async function cleanUpiModels(params: {
  imodelsClient: ManagementiModelsClient | AuthoringiModelsClient,
  requestContext: RequestContext,
  projectId: string,
  testiModelGroup: TestiModelGroup,
}): Promise<void> {
  const imodels = params.imodelsClient.iModels.getMinimalList({
    requestContext: params.requestContext,
    urlParams: {
      projectId: params.projectId
    }
  });
  for await (const imodel of imodels)
    if (params.testiModelGroup.doesiModelBelongToContext(imodel.displayName))
      await params.imodelsClient.iModels.delete({
        requestContext: params.requestContext,
        imodelId: imodel.id
      });
}

export async function findiModelWithName(params: {
  imodelsClient: ManagementiModelsClient | AuthoringiModelsClient,
  requestContext: RequestContext,
  projectId: string,
  expectediModelname: string
}): Promise<iModel> {
  const imodels = params.imodelsClient.iModels.getRepresentationList({
    requestContext: params.requestContext,
    urlParams: {
      projectId: params.projectId
    }
  });
  for await (const imodel of imodels)
    if (imodel.displayName === params.expectediModelname)
      return imodel;

  throw new TestSetupError(`Failed to find an iModel with name ${params.expectediModelname}.`);
}

export function cleanupDirectory(directory: string): void {
  if (fs.existsSync(directory)) {
    fs.rmdirSync(directory, { recursive: true });
    fs.mkdirSync(directory);
  }
}
